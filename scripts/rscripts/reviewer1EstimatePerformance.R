##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '
## Jan 2011 Th17 project (MCZ,tlCLR,Inferelator)
## Bonneau lab - "Aviv Madar" <am2654@nyu.edu>, 
## NYU - Center for Genomics and Systems Biology
##  .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.   .-.-.
## /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ /|/ \|\ / / \ \ / / \ \
##`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   `-`-'   ' '
cat("\n- setting global variables\n")
rm(list=ls())
GLOBAL <- list()
#GLOBAL[["run.these.steps"]] <- c("12.1.1","14.1.1","14.2.1") # for a complete run c(1:last_step)
GLOBAL[["run.these.steps"]] <- c(12.2)
# stamp the date on this run
x <- unlist(strsplit(date()," +",perl=TRUE))
GLOBAL[["date.is"]] <- paste(x[2],x[3],x[5],sep="_")
# data set size: take genes with abs(zscore) based on diff expression btwn th17_48hr and th0_48hr
GLOBAL[["z.abs.cut"]] <- 2.5 #zscore
# Only used to determine rnaseq data set size
# GLOBAL[["median.abs.cut"]] <- 3 #rpkm
GLOBAL[["min.th17.or.th0.rpkm"]] <- 3 #rpkm
# The number of bootstraps for inferelator rnaseq and immgen
GLOBAL[["num.boots.rnaseq"]] <- 200
GLOBAL[["num.boots.immgen"]] <- 200
GLOBAL[["num.perms.enrichment.analysis"]] <- 10
# do we want to output the sequences around the peaks?
GLOBAL[["get.sequence"]] <- TRUE
# what is the minimum distance between peaks to cluster them together
## GLOBAL[["tfs.min.dist"]] <- c(50,100,150,200,250,300,500,1000)
GLOBAL[["tfs.min.dist"]] <- c(100)
# multi TF binding sites distance (up/downstrem) from TSS for gene MTBS mapping
GLOBAL[["mtbs.tss.dist"]] <- 5000
GLOBAL[["mm9.effective.genome.size"]] <- 1.87e9

# genes that we want in as a rule even if they have low median expression or z.score that kicks them out
GLOBAL[["known.tfs"]] <- c("BATF","MAF","IRF4","STAT3","RORC")
GLOBAL[["known.gns"]] <- toupper(c("Il17a","Il17f","Il23r","Il22","Il21","Foxp3","Rora"))
GLOBAL[["use.multicore"]] <- TRUE
if(GLOBAL[["use.multicore"]]==TRUE){
  library(multicore)
}

	rm(list=ls()[-which(ls()=="GLOBAL")])
	cat("\n- calculating validation plots for targets recovery\n")
	date.is <- GLOBAL[["date.is"]]
	cut.dist <- 100 # only consider snps within 100kb
	gs.list <- "th17"
	gold.stdrd.date <- "Jun_22_2012"
	fl.nm.gs <- paste(sep="","gold_standard_",gs.list,"_genes_",gold.stdrd.date,".txt")
	date.combine.data.run <- "Sep_6_2012"	
	core.tfs <- GLOBAL[["known.tfs"]]
	prcnt.chng.cut <- 0
	deseq.pval.cut <- 1
	c.type.all.in.one.plot <- "th17"
	tfs <- c("BATF","MAF","IRF4","STAT3","RORC")
	num.tfs <- length(tfs) # 8 or 5 (5=core.tfs,8=core.tfs+etv6,fosl2,hif1a)
	z.abs.cut <- GLOBAL[["z.abs.cut"]]
	filter.by.sam <- F
	comb.case <- "activation" # or activation or repression or absolute
	Np=10




# R code to create quality control plots for entire network pipeline
library(caTools) # to use integration under curve (Trapezoid Rule Numerical Integration)
source("r_scripts/th17/used_for_paper/simulations_util.R")
source("r_scripts/th17/used_for_paper/util.R")


path.input.gold.standard <- "input/th17/used_for_paper/gold_standard_lists/"
path.output <- paste(sep="","results/validation/",date.is,"/")
system(paste(sep="","mkdir ", path.output))			
path.input.sam <- "input/th17/used_for_paper/"
path.input.combined <- paste(sep="","results/combinedAnalysis/",date.combine.data.run,"/")
# make output directory
if(any("P300" %in% tfs)){
	num.tfs.tmp <- num.tfs-1
} else {
	num.tfs.tmp <- num.tfs
}
if(filter.by.sam==TRUE){
	add.str <- paste(sep="","_cut_prcnt_",prcnt.chng.cut,"_num_tfs_",num.tfs.tmp,"_sam_",z.abs.cut,"_deseq_cut_",deseq.pval.cut)
} else {
	add.str <- paste(sep="","_cut_prcnt_",prcnt.chng.cut,"_num_tfs_",num.tfs.tmp,"_sam_",0,"_deseq_cut_",deseq.pval.cut)
}
infl.nm <- paste(path.input.combined,"results_combine_data_exprsn",add.str,".Rdata",sep="")
# load input files
load(infl.nm)
keepers <- colnames(res[[1]][[1]][[1]])[1:16]
## gold standard files
th17.gns.f.nm <- paste(sep="",path.input.gold.standard,fl.nm.gs)
gs.gns <- read.delim(sep="\t",header=T,th17.gns.f.nm, as.is=T)
ix <- which(gs.gns$distance<cut.dist)
gs.gns <- toupper(gs.gns[,"gene_id"])[ix]

########################################
# for efficiency of simulation code 
# keep only data used in res
########################################
tp <- comb.case # e.g. tp = activation
if(tp=="absolute"){
	res[[tp]] <- list()
	for(i in 1:length(res[["whole"]])){
		tf <- names(res[["whole"]])[i]
		res[[tp]][[tf]] <- list()
		for(j in 1:length(res[["whole"]][[tf]])){
			c.tp <- names(res[["whole"]][[tf]])[j]
			res[[tp]][[tf]][[c.tp]] <- abs(res[["whole"]][[tf]][[j]][,keepers])
		}
	}
}
c.tp <- c.type.all.in.one.plot # e.g. chip comes for Th17
res.tmp <- list() # create a reduced list of res for only conditions we want to look at
for(j in 1:length(tfs)){ # go over tfs
	tf <- tfs[j]
	res.tmp[[tf]] <- res[[tp]][[tf]][[c.tp]]
}
res.orig <- res.tmp
rm(res.tmp)
########################################
# if dealing with repression
# make sam scores opposite sign so we can plot performance of sam if we wish
# otherwise absolute sign
########################################
if(tp=="repression"){
	res.orig[[1]][,"SAM"] <- -1*res.orig[[1]][,"SAM"]
} else if (tp=="absolute"){
	res.orig[[1]][,"SAM"] <- abs(res.orig[[1]][,"SAM"])
}
########################################
# to make simulations more realistic
# limit R,I datasets to only consider
# diff expressed genes 
# as this is what we have done with 
# original data
########################################
m <- res.orig[[1]] # a sample matrix of results
# this are the allowed genes for Chip (all genes)
ix.chip <- 1:nrow(m)
# this are the allowed genes for KO (genes with rpkm > 3 in either th17 or th0) this is more conservative than what we acutally did (or >3 in either ko or wt)
# ix.ko <- which( (abs(m[,"th17_rpkm"])>min.rpkm) | (abs(m[,"th0_rpkm"])>min.rpkm) ) 
ix.ko <- 1:nrow(m)
# this are the allowed genes for Immgen and RNAseq (genes with absolute sam th17 vs. th0 bigger than 2.5)
# ix.immgen <- which(abs(m[,"SAM"])>z.abs.cut)
# ix.rnaseq <- which(abs(m[,"SAM"])>z.abs.cut)
ix.immgen <- 1:nrow(m)
ix.rnaseq <- 1:nrow(m)
########################################
# start running permuations
########################################
# here we will keep auc's (1'st auc stored is for real net, the rest are permutations)
aucPR.single.tf <- list()
aucROC.single.tf <- list()
aucPR.5way <- list()
aucROC.5way <- list()

fisher.method <- function(w){
	tmp <- abs(w)
	w.chi <- apply(tmp,1,function(i) 2*sum(i) )
	return(pchisq(w.chi, df=2*ncol(tmp), lower.tail = F,log.p = T))
}

for(p in 1:Np){
	# first permutation is real data other wise we permute data to get random aucPR/aucROC
	if(p>1){
		res <- list()
		for(j in 1:length(tfs)){ # go over tfs
			tf <- tfs[j]
			# permutations individucally for each core data type (K,C,R,I)
			ix.sample.chip <- sample(ix.chip)
			ix.sample.ko <- sample(ix.ko)
			ix.sample.immgen <- sample(ix.immgen)
			ix.sample.rnaseq <- sample(ix.rnaseq)
			res[[tf]] <- simulate.combine.data(res.orig[[tf]],
									ix.chip,ix.ko,ix.immgen,ix.rnaseq,
									ix.sample.chip,ix.sample.ko,ix.sample.immgen,ix.sample.rnaseq)
		}
	} else {
		res <- res.orig
	}
	########################################
	# sum scores over tfs
	########################################
	ix.add <- 1:15 # only add for K,C,R,I or combination (not for sam, deseq, etc)
	o.sum.list <- res[[1]] # here we store the summed scores over all tfs
	o.sum.list[,ix.add] <- 0
	for(j in 1:length(ix.add)){
		w <- matrix(0,nr=nrow(res[[1]]),nc=length(tfs))
		colnames(w) <- tfs
		rownames(w) <- rownames((res[[1]]))
		for(v in 1:length(tfs)) {
			tf <- tfs[v]
			w[,tf] <- res[[tf]][,ix.add[j]]
		}
		o.sum.list[,ix.add[j]] <- -log10(exp(1))*(fisher.method(w*log(10)))
	}
	
	# for(j in 1:length(tfs)){ # go over tfs
	# 	tf <- tfs[j]
	# 	if(j==1){ # if first tf start the summation
	# 		o.sum.list <- res[[tf]]
	# 	} else {
	# 		o.sum.list[,ix.add] <- o.sum.list[,ix.add] + res[[tf]][,ix.add]
	# 	}
	# }
	########################################
	# convert summed scores into relative ranks for ploting
	########################################
	# convert combined scores for multiple tfs into relative ranks for ploting
	o.sum.rel.list <- list() # here we store the summed scores over all tfs
	# prepare list of matrices to store data for relative ranks
	gns <- rownames(o.sum.list)
	o.sum.rel.list <- matrix(0,nr=nrow(o.sum.list),nc=ncol(o.sum.list))
	colnames(o.sum.rel.list) <- colnames(o.sum.list)
	for(j in 1:ncol(o.sum.list)){
		o.sum.rel.list[,j] <- gns[order(o.sum.list[,j],decreasing=T)]
	}
	########################################
	# convert single TF scores into relative ranks for ploting
	########################################
	o.rel.list <- list() # here we store the relative scores for each tfs
	for(i in 1:length(tfs)){ # go over tfs
		tf <- tfs[i]	
		# prepare list of matrices to store data for relative ranks
		gns <- rownames(res[[tf]])
		o.rel.list[[tf]] <- matrix(0,nr=nrow(res[[tf]]),nc=ncol(res[[tf]]))
		colnames(o.rel.list[[tf]]) <- colnames(res[[tf]])
		for(j in 1:ncol(o.rel.list[[tf]])){
			o.rel.list[[tf]][,j] <- gns[order(res[[tf]][,j],decreasing=T)]
		}
	}

	########################################
	# calc GSEA for summed scores
	########################################
	RES <- list()
	ES <- list()
	arg.ES <- list()
	IHIT <- list()
	for(i in 1:length(keepers)){
		w <- sort(o.sum.list[,keepers[i]],decreasing=T)
		gene.list <- names(w)
		gene.list.scores <- w
		gene.set <- gs.gns
		o <- GSEA.EnrichmentScore(gene.list=gene.list,gene.set=gene.set,weighted.score.type = 1,correl.vector=gene.list.scores)
		RES[[ keepers[i] ]] <- o$RES
		ES[[ keepers[i] ]] <- o$ES
		arg.ES[[ keepers[i] ]] <- o$arg.ES
		IHIT[[ keepers[i] ]] <- o$indicator
	}

	########################################
	# calc aucPR/aucROC for summed scores
	########################################
	prec <- list()
	rec <- list()
	tpr <- list()
	fpr <- list()
	AUCPR <- list()
	AUCROC <- list()
	x.rel.nms <- o.sum.rel.list
	x.rel <- seq(from=0,to=1,length.out=dim(x.rel.nms)[1])
	gold.gns <-  gs.gns
	positive.rel.ranks <- list() # find what relative ranks gold std gns received
	for(j in 1:length(keepers)){
		positive.rel.ranks[[ keepers[j] ]] <- x.rel[which(x.rel.nms[,keepers[j]]%in%gs.gns)]
	}
	# calc precision vs. recal and roc curve
	for(i in 1:length(keepers)){
		x <- positive.rel.ranks[[ keepers[i] ]]
		neg.tot <- length(x.rel)-length(x)
		tp <- numeric(length(x)) # true positive so far (elem j)
		fp <- numeric(length(x)) # false positive so far, fp.j= total positive minus true positive so far 
		fn <-  numeric(length(x)) # true negative so far, tn.j= total so far minus positive so far
		tn <- numeric(length(x))	
		for(j in 1:length(positive.rel.ranks[[i]])){
			tp[j] <- j # true positive so far (elem j)
			fp[j] <- (which(x.rel==x[j])-j) # false positive so far, fp.j= total positive minus true positive so far 
			fn[j] <-  length(x) - j # true negative so far, tn.j= total so far minus positive so far
			tn[j] <- neg.tot-fp[j]
		}
		prec[[ keepers[i] ]] <- tp/(tp+fp)
		rec[[ keepers[i] ]] <- tp/(tp+fn)
		tpr[[ keepers[i] ]] <- c(tp/(tp+fn),1)
		fpr[[ keepers[i] ]] <- c(fp/(fp+tn),1)
		AUCPR[[ keepers[i] ]] <- trapz(x=rec[[ keepers[i] ]], 
												y=prec[[ keepers[i] ]])
		AUCROC[[ keepers[i] ]] <- trapz(x=fpr[[ keepers[i] ]], 
												y=tpr[[ keepers[i] ]])
	}
	# keep AUC values
	aucPR.5way[[p]] <- AUCPR
	aucROC.5way[[p]] <- AUCROC
	if(p==1 | p==2 & 1){
		if(p==2 & 0){
			f.nm <- paste(sep="",path.output,"gsea_",gs.list,"_",comb.case,".pdf")
			pdf(f.nm)
			cls <- c("firebrick3",
						rgb(255, 106, 106,maxColorValue=255, 150),
						rgb(154, 205, 50,maxColorValue=255, 150),
						"darkgray")
			nf <- layout(rbind(1,2,3),heights=c(3,1,2))
			op <- par(mar=c(0,7,0.5,0.5),mgp=c(4, 1, 0))
			n <- length(RES[["KCRI"]])
			y <- RES[["KCRI"]]
			x <- 1:n
			plot(x=x,y=y,type="l",lwd=3,col=cls[4],cex.lab=2,ylim=c(0,1),
			ylab="Enrichment Score (ES)",xaxt="n",xlab="",cex.axis=2,las=1)
			y <- RES.1[["KCRI"]]
			lines(x=x,y=y,type="l",lwd=3,col=cls[1])
			legend(y=1,x=(n-8000),legend=c("K+C+R+I","Random"),lty=1,lwd=3,col=cls[c(1,4)],cex=2)

			plot(y=c(-0.05,0.05),x=c(1,1),col="gray89",type="l",lty=1,xlim=c(0,n),lwd=0.1,
			xlab="",ylab="",axes=F,ylim=c(-1,1))
			s <- IHIT[["KCRI"]]
			for(i in 1:n){
				if(s[i]==0){
					lines(y=c(-1,-0.1),x=c(i,i),col="gray89",lwd=0.1)
				} else {
					lines(y=c(-1,-0.1),x=c(i,i),col="darkred",lwd=2)				
				}
			}
			s <- IHIT.1[["KCRI"]]
			for(i in 1:n){
				if(s[i]==0){
					lines(y=c(0.1,1),x=c(i,i),col="gray89",lwd=0.1)
				} else {
					lines(y=c(0.1,1),x=c(i,i),col="darkred",lwd=2)				
				}
			}
			# add blue line where leading edge (enriched set end)
			lines(y=c(-1,-0.1),x=c(arg.ES[["KCRI"]],arg.ES[["KCRI"]]),col="darkblue",lwd=5)
			lines(y=c(0.1,1),x=c(arg.ES.1[["KCRI"]],arg.ES.1[["KCRI"]]),col="darkblue",lwd=5)
			text(y=c(0.5),x=c(arg.ES.1[["KCRI"]])+50,labels="ES max",cex=2,pos=4,col="darkblue")
			text(y=c(-0.5),x=c(arg.ES[["KCRI"]])+50,labels="ES max",cex=2,pos=4,col="darkblue")
			mtext("K+C+R+I",side=2,cex=1.5,las=1,line = -1,at=0.5)
			mtext("Random",side=2,cex=1.5,las=1,line = -1,at=-0.5)

			par(mar=c(4.5,7,0.5,0.5),mgp=c(3, 1, 0))
			x <- sort(o.sum.list.1[,"KCRI"],decreasing=T)
			plot(y=c(x[1]),x=c(1),col=cls[1],pch=20,lty=1,xlim=c(0,n),cex.axis=2,cex.lab=2,las=1,lwd=0.5,
			ylab="Network score",xlab="Ranked gene list",ylim=c(min(x),max(x)))
			legend(y=max(x)-1,x=(n-8000),legend=c("K+C+R+I","random"),lty=1,lwd=3,col=cls[c(1,4)],cex=2)
			lines(x=1:n,y=x,pch=20,col=cls[1],lwd=4)
			x <- sort(o.sum.list[,"KCRI"],decreasing=T)
			lines(x=1:n,y=x,pch=20,col=cls[4],lwd=4)			
			dev.off()
			# 
			# for(i in 1:n){
			# 		lines(y=c(0,x[i]),x=c(i,i),col=cls[1],lwd=0.1)
			# }
			# x <- sort(o.sum.list[,"KCRI"],decreasing=T)
			# for(i in 1:n){
			# 		lines(y=c(0,x[i]),x=c(i,i),col=cls[2],lwd=0.1)
			# }
			# points(x=1:n,y=x,pch=20,col="gray",cex=0.5)

		} else {
			o.sum.list.1 <- o.sum.list
			IHIT.1 <- IHIT
			RES.1 <- RES
			arg.ES.1 <- arg.ES
		}
		if(p==1){
			cls <- c(rgb(221, 160, 221,maxColorValue=255, 250),
						rgb(255, 106, 106,maxColorValue=255, 150),
						rgb(154, 205, 50,maxColorValue=255, 150),
						"gray")
			f.nm <- paste(sep="",path.output,"pr_vs_recall_",gs.list,"_",comb.case,".pdf")
			pdf(f.nm)
			cls <- c(rgb(221, 160, 221,maxColorValue=255, 250),
						rgb(255, 106, 106,maxColorValue=255, 150),
						rgb(154, 205, 50,maxColorValue=255, 150),
						"gray")
			par(mar=c(4.5,5,1,1))
			n <- nrow(x.rel.nms)
			hits.on.s.kcri <- (positive.rel.ranks[["KCRI"]]*n)+1
			hits.on.s.kc <- (positive.rel.ranks[["KC"]]*n)+1
			hits.on.s.ri <- (positive.rel.ranks[["RI"]]*n)+1
			hits.on.s.sam <- (positive.rel.ranks[["SAM"]]*n)+1

			par(mar=c(4.5,5,1,1))
			plot(rec[["KCRI"]],prec[["KCRI"]],type="l",lwd=5,col=cls[1],
			ylab="Precistion [TP/(TP+FP)]",xlab="Recall [TP/(TP+FN)]",xlim=c(0,1),cex.lab=2)

			lines(rec[["KC"]],prec[["KC"]],type="l",lwd=5,col=cls[2])
			lines(rec[["RI"]],prec[["RI"]],type="l",lwd=5,col=cls[3])
			lines(rec[["SAM"]],prec[["SAM"]],type="l",lwd=5,col=cls[4])
			legend("topright",lty=1,legend=c("KCRI","KC","RI","SAM"),col=cls,cex=1.5,lwd=5)	

			plot(y=c(-0.05,0.05),x=c(1,1),col="gray",type="l",lty=1,xlim=c(0,n),lwd=0.1,
			xlab="",ylab="",axes=F,ylim=c(-6,3))
			s <- seq(1,n,by=1)
			for(i in s){
				lines(y=c(3,2),x=c(i,i),col="gray",lwd=0.1)
				lines(y=c(-0.5,0.5),x=c(i,i),col="gray",lwd=0.1)
				lines(y=c(-3,-2),x=c(i,i),col="gray",lwd=0.1)
				lines(y=c(-5.5,-4.5),x=c(i,i),col="gray",lwd=0.1)
			}
			for(i in hits.on.s.kcri){
				lines(y=c(3,2),x=c(i,i),col="darkred",lwd=0.2)
			}
			for(i in hits.on.s.kc){
				lines(y=c(-0.5,0.5),x=c(i,i),col="darkred",lwd=0.2)
			}
			for(i in hits.on.s.ri){
				lines(y=c(-3,-2),x=c(i,i),col="darkred",lwd=0.2)
			}
			for(i in hits.on.s.sam){
				lines(y=c(-5.5,-4.5),x=c(i,i),col="darkred",lwd=0.2)
			}
			axis(2,at=c(2.5,0,-2.5,-5),labels=c("KCRI","KC","RI","SAM"),las=2)
			dev.off()
		}
	}
	########################################
	# calc aucPR/aucROC for single TFs
	########################################
	prec <- list()
	rec <- list()
	tpr <- list()
	fpr <- list()
	AUCPR <- list()
	AUCROC <- list()
	for(k in 1:length(tfs)){ # go over tfs
		tf <- tfs[k]	
		x.rel.nms <- o.rel.list[[tf]]
		x.rel <- seq(from=0,to=1,length.out=dim(x.rel.nms)[1])
		gold.gns <- gs.gns

		positive.rel.ranks <- list() # find what relative ranks gold std gns received
		for(j in 1:length(keepers)){
			positive.rel.ranks[[ keepers[j] ]] <- x.rel[which(x.rel.nms[,keepers[j]]%in%gs.gns)]
		}	
		prec[[tf]] <- list()
		rec[[tf]] <- list()
		tpr[[tf]] <- list()
		fpr[[tf]] <- list()
		AUCPR[[tf]] <- list()
		AUCROC[[tf]] <- list()
		for(i in 1:length(keepers)){
			x <- positive.rel.ranks[[ keepers[i] ]]
			neg.tot <- length(x.rel)-length(x)
			# fpr[[ keepers[i] ]] <- numeric(length(positive.rel.ranks[[i]]))
			tp <- numeric(length(x)) # true positive so far (elem j)
			fp <- numeric(length(x)) # false positive so far, fp.j= total positive minus true positive so far 
			fn <-  numeric(length(x)) # true negative so far, tn.j= total so far minus positive so far
			tn <- numeric(length(x))	
			for(j in 1:length(positive.rel.ranks[[i]])){
				tp[j] <- j # true positive so far (elem j)
				fp[j] <- (which(x.rel==x[j])-j) # false positive so far, fp.j= total positive minus true positive so far 
				fn[j] <-  length(x) - j # true negative so far, tn.j= total so far minus positive so far
				tn[j] <- neg.tot-fp[j]
			}
			prec[[tf]][[ keepers[i] ]] <- tp/(tp+fp)
			rec[[tf]][[ keepers[i] ]] <- tp/(tp+fn)
			tpr[[tf]][[ keepers[i] ]] <- c(tp/(tp+fn),1)
			fpr[[tf]][[ keepers[i] ]] <- c(fp/(fp+tn),1)
			AUCPR[[tf]][[ keepers[i] ]] <- trapz(x=rec[[tf]][[ keepers[i] ]], 
													y=prec[[tf]][[ keepers[i] ]])
			AUCROC[[tf]][[ keepers[i] ]] <- trapz(x=fpr[[tf]][[ keepers[i] ]], 
													y=tpr[[tf]][[ keepers[i] ]])
		}
	}
	aucPR.single.tf[[p]] <- AUCPR
	aucROC.single.tf[[p]] <- AUCROC
}
aucPR.sam <- aucPR.single.tf[[1]][[1]][["SAM"]]
aucROC.sam <- aucROC.single.tf[[1]][[1]][["SAM"]]

# helper function to capitalize tfs name (only first letter is capped)
capwords <- function(s, strict = FALSE) {
    cap <- function(s) paste(toupper(substring(s,1,1)),
                  {s <- substring(s,2); if(strict) tolower(s) else s},
                             sep = "", collapse = " " )
    sapply(strsplit(s, split = " "), cap, USE.NAMES = !is.null(names(s)))
}


f.nm.res.pdf <- paste(sep="",path.output, "vldtn_perTF_AllInOne2_",comb.case,"_",
						c.type.all.in.one.plot,add.str,"_gs_data_",gs.list,"_",gold.stdrd.date,".pdf")

# reorganize ix to make trends between comb levels clear
ix=c("I","R","C","K","CI","CR","KR","RI","KI","KC","KCR","CRI","KRI","KCI","KCRI")


# get real results
AUCPR <- aucPR.single.tf[[1]]
AUCROC <- aucROC.single.tf[[1]]
AUCPR.5.way <- aucPR.5way[[1]]
AUCROC.5.way <- aucROC.5way[[1]]
# get random results in a nice list for easy plotting
# first for single tf scores
aucpr.rand <- list()
aucroc.rand <- list()
for(k in 1:length(tfs)){
	tf <- tfs[k]
	aucpr.rand[[tf]] <- list()
	aucroc.rand[[tf]] <- list()	
	for(p in 2:Np){
		for(l in 1:length(ix)){
			combo <- ix[l]
			aucpr.rand[[tf]][[combo]] <- c(aucpr.rand[[tf]][[combo]],aucPR.single.tf[[p]][[tf]][[combo]])
			aucroc.rand[[tf]][[combo]] <- c(aucroc.rand[[tf]][[combo]],aucROC.single.tf[[p]][[tf]][[combo]])			
		}	
	}
}

# now for summed scores 5 way
aucpr.5way.rand <- list()
aucroc.5way.rand <- list()
for(p in 2:Np){
	for(l in 1:length(ix)){
		combo <- ix[l]
		aucpr.5way.rand[[combo]] <- c(aucpr.5way.rand[[combo]],aucPR.5way[[p]][[combo]])
		aucroc.5way.rand[[combo]] <- c(aucroc.5way.rand[[combo]],aucROC.5way[[p]][[combo]])			
	}
}

r.vec.single.pr <- r.vec.single.roc <- matrix(0,nr=Np-1,nc=length(ix))
colnames(r.vec.single.pr) <- colnames(r.vec.single.roc) <- ix
for(i in 1:length(ix)){
	# q percentile
	d.type <- ix[i]
	for(k in 1:length(tfs)){
		r.vec.single.pr[,d.type] <- aucpr.rand[[tf]][[d.type]]
		r.vec.single.roc[,d.type] <- aucroc.rand[[tf]][[d.type]]
	}	
}
r.vec.sum.pr <- r.vec.sum.roc <- matrix(0,nr=Np-1,nc=length(ix))
colnames(r.vec.sum.pr) <- colnames(r.vec.sum.roc) <- ix
for(i in 1:length(ix)){
	# q percentile
	d.type <- ix[i]
	r.vec.sum.pr[,d.type] <- aucpr.5way.rand[[d.type]]
	r.vec.sum.roc[,d.type] <- aucroc.5way.rand[[d.type]]
}
pr.rand.95.prcntile <- quantile(r.vec.sum.pr,0.95)
roc.rand.95.prcntile <- quantile(r.vec.sum.roc,0.95)


# colors for tfs: "BATF"  "MAF"   "IRF4"  "STAT3" "RORC"
cls <- c(colors()[566],#BATF="royalblue1"
		 colors()[642],#MAF=violetred1
		 colors()[496],#IRF4=olivedrab3
		 colors()[512],#STAT3=orchid4
		 colors()[566])#RORC=royalblue1
pchs <-	c(18,#BATF=diamond (full)
		 15,#MAF=square (full)
		 17,#IRF4=triangle (full)
		 16)#STAT3=circle full)
rorc.pch <- 25 #RORC=dodgerblue	
# colors for sum scores bar plots: 
cls.bars <- c(rep(colors()[616],4),#k,c,r,i=steelblue1
		 rep(colors()[652],6),#two ways=yellow
		 rep(colors()[136],5))#three-fourways=firebrick3
pt.cexs <- c(1.2,
			 1.2,
			 1.2,
			 1.2,
			 1)

type <- comb.case
pdf(f.nm.res.pdf )
for(i in 1:length(ix)){ # go over datatypes
	d.type <- ix[i]
	for(k in 1:length(tfs)){ # go over tfs
		tf <- tfs[k]
		x <- AUCPR
		ylim <- c(0,0.4)
		xlim <- c(1,length(ix))
		if(k==1 & i==1){
			plot(y=x[[tf]][ix][1],x=k,pch=pchs[k],main=paste(sep="---",type,c.tp),xlim=xlim,ylim=ylim,col=cls[k],
			xlab="Datatype",ylab="Area Under Curve PR",cex=1.5,type="n",axes = FALSE)
			axis(2,cex.axis=2)
			text(1:length(ix), par("usr")[3], labels = ix, srt = 90, adj = 1, xpd = TRUE,cex=1)
		}
		if(k==1){
			barplot(AUCPR.5.way[[d.type]],space=i-0.5,width=1,col=cls.bars[i],add=T,axes = FALSE,names.arg="")
		}
		if(tf=="RORC"){
			points(y=x[[tf]][d.type],x=i,pch=rorc.pch,cex=pt.cexs[k],col=cls[k],bg = cls[k])			
		} else {
			points(y=x[[tf]][d.type],x=i,pch=pchs[k],cex=pt.cexs[k],col=cls[k])			
		}
	}
}
# put random 95 percentile line
y=pr.rand.95.prcntile
lines(x=c(-1,100),y=c(y,y),lwd=3,lty=2)
y <- aucPR.sam
lines(x=c(-1,100),y=c(y,y),lwd=3,lty=3)
legend(x=1,y=0.4,capwords(rev(c(tolower(tfs),"combined"))),col=rev(c(cls,"black")),pch=rev(c(pchs,rorc.pch,0)),pt.bg = cls[k],pt.cex=c(1,rev(pt.cexs)))
legend(x=6,y=0.4,capwords(rev(c("random","differential expression"))),col=rev(c("black","black")),lty=rev(c(2,3)),lwd=rev(c(3,3)))

# ix=c("I","R","K","C","KR","KI","RI","KC","CI","CR","KCR","CRI","KCI","KRI","KCRI")
# legend("topleft",capwords(rev(c(tolower(tfs),"combined"))),col=rev(c(cls,"black")),pch=rev(c(rep(pch,length(tfs)),8)))
for(i in 1:length(ix)){ # go over datatypes
	d.type <- ix[i]
	for(k in 1:length(tfs)){ # go over tfs
		tf <- tfs[k]
		x <- AUCROC
		ylim <- c(0.5,1)
		xlim <- c(1,length(ix))
		if(k==1 & i==1){
			plot(y=x[[tf]][ix][1],x=k,pch=pchs[k],main=paste(sep="---",type,c.tp),xlim=xlim,ylim=ylim,col=cls[k],
			xlab="Datatype",ylab="Area Under Curve PR",cex=1.5,type="n",axes = FALSE)
			axis(2,cex.axis=2)
			text(1:length(ix), par("usr")[3], labels = ix, srt = 90, adj = 1, xpd = TRUE,cex=1)
		}
		if(k==1){
			barplot(AUCROC.5.way[[d.type]],space=i-0.5,width=1,col=cls.bars[i],add=T,axes = FALSE)
		}
		if(tf=="RORC"){
			points(y=x[[tf]][d.type],x=i,pch=rorc.pch,cex=pt.cexs[k],col=cls[k],bg = cls[k])			
		} else {
			points(y=x[[tf]][d.type],x=i,pch=pchs[k],cex=pt.cexs[k],col=cls[k])			
		}
	}
}
y=roc.rand.95.prcntile
lines(x=c(-1,100),y=c(y,y),lwd=3,lty=2)
y <- aucROC.sam
lines(x=c(-1,100),y=c(y,y),lwd=3,lty=3)
text(1:length(ix), par("usr")[3], labels = ix, srt = 90, adj = 1, xpd = TRUE,cex=1)
dev.off()














